{
  "ver": "1.0.25",
  "uuid": "daf388a9-244f-4b6b-8bc4-9ee92650c3b7",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\nvarying vec3 v_normal;\nvarying vec4 v_data;\nvarying vec4 v_worldpos;\nvarying vec4 v_vspos;\nuniform vec4 terrainparam;\nuniform sampler2D texture;\nvoid main () {\n  float heightbase = texture2D(texture,   a_uv0 + vec2(0,0)).r;\n  vec3 origin = a_position + vec3(0.0,heightbase *    terrainparam.x,0.0);\n  vec4 pos = vec4(origin,1.0);\n  v_worldpos =  cc_matWorld * pos;\n  v_uv0 = a_uv0;\n  v_data = vec4(heightbase,0.5,heightbase,heightbase);\n  v_vspos = cc_matView * cc_matWorld * pos;\n  gl_Position = cc_matViewProj * cc_matWorld * pos;\n}",
        "frag": "\nprecision highp float;\nuniform vec4 cc_cameraPos;\nvarying vec2 v_uv0;\nvarying vec3 v_normal;\nvarying vec4 v_data;\nvarying vec4 v_worldpos;\nvarying vec4 v_vspos;\nuniform vec4 fogcolor;\nuniform sampler2D texture;\nuniform sampler2D layertexture;\nuniform sampler2D normaltexture;\nuniform sampler2D noise;\nfloat noise3d( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = texture2D(noise,(uv+0.5)/256.0,0.0).yx;\n    return -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\nfloat noise3dfbm3( in vec3 p )\n{\n  vec3 q = p;\n  float f;\n    f  = 0.50000*noise3d( q ); q = q*2.02;\n    f += 0.25000*noise3d( q ); q = q*2.03;\n    f += 0.12500*noise3d( q );\n  return clamp( 1.75*f, 0.0, 1.0 );\n}\nvec4 ColorRamp2Exp(float factor, float power, float pos0, float pos1, vec4 color0, vec4 color1){\n    vec4 outColor = color0;\n    if(factor >= pos0 && factor < pos1)\n    {\n        float localFactor = (factor - pos0)/(pos1 - pos0);\n        outColor =  mix(color0, color1, pow(localFactor, power));\n    }\n    else if (factor > pos1)\n    {\n        outColor = color1;\n    }\n    return outColor;\n}\nvoid main () {\n  vec4 data = texture2D(texture, v_uv0);\n  vec4 normalPS = texture2D(normaltexture, v_uv0);\n  float scale = 40.0;\n  float x0 = noise3d((v_worldpos.xyz + vec3(1,0,0))*  scale);\n  float x1 = noise3d((v_worldpos.xyz + vec3(-1,0,0))* scale);\n  float y0 = noise3d((v_worldpos.xyz + vec3(0,0,1))*  scale);\n  float y1 = noise3d((v_worldpos.xyz + vec3(0,0,-1))* scale);\n  float s = 10.0;\n  vec3 n = normalize(vec3(x1 - x0, s, y1 - y0));\n  normalPS.xyz = normalPS.xyz * 2.0 - 1.0;\n  normalPS.xyz = normalize(normalPS.xyz + n);\n  float noisedata = noise3dfbm3(v_worldpos.xyz*0.1);\n  vec3 albedo = texture2D(layertexture, v_data.xy + vec2((noisedata - 0.5) * 0.5 * max(0.0, v_data.x - 0.5))).rgb;\n  vec3 normal = -(normalPS.xyz);\n  vec3 lightcolor = normalize(vec3(1.0,-0.25,0.0));\n  float ndotl = max(0.0, dot(normal, lightcolor));\n  vec3 light = mix( vec3(0.02,0.03,0.1), vec3(0.3,0.4,0.9), data.g * data.g) + vec3(1.0,0.95,0.7) * 2.0 * ndotl * min(data.b, data.a);\n  vec4 final = vec4(1,1,1,1);\n  final.rgb = light * albedo * albedo;\n  float linearZ = v_worldpos.y * 0.004;\n  float linearDepth = length(v_worldpos.xyz - cc_cameraPos.xyz) / 1200.0;\n  vec4 heightFog = ColorRamp2Exp(linearZ, 0.2, 0.0, 0.6, vec4(1,1,1,1), vec4(0));\n  vec4 distFog = ColorRamp2Exp(linearDepth, 2.0, 0.0, 0.5, vec4(0), vec4(1));\n  distFog *= min(vec4(1), heightFog * 5.0);\n  final.rgb = mix(final.rgb, fogcolor.rgb * fogcolor.rgb, distFog.rgb * fogcolor.a);\n  final.rgb *= 0.5;\n  final.rgb = sqrt(final.rgb);\n  final.a = -v_vspos.z / 500.0;\n  gl_FragColor = final;\n}"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec2 a_uv0;\nout vec2 v_uv0;\nout vec3 v_normal;\nout vec4 v_data;\nout vec4 v_worldpos;\nout vec4 v_vspos;\nuniform UNLIT {\n  vec4 textureparam;\n  vec4 terrainparam;\n};\nuniform sampler2D texture;\nvoid main () {\n  float heightbase = texture2D(texture,   a_uv0 + vec2(0,0)).r;\n  vec3 origin = a_position + vec3(0.0,heightbase *    terrainparam.x,0.0);\n  vec4 pos = vec4(origin,1.0);\n  v_worldpos =  cc_matWorld * pos;\n  v_uv0 = a_uv0;\n  v_data = vec4(heightbase,0.5,heightbase,heightbase);\n  v_vspos = cc_matView * cc_matWorld * pos;\n  gl_Position = cc_matViewProj * cc_matWorld * pos;\n}",
        "frag": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nin vec2 v_uv0;\nin vec3 v_normal;\nin vec4 v_data;\nin vec4 v_worldpos;\nin vec4 v_vspos;\nuniform UNLITPS {\n  vec4 fogcolor;\n};\nuniform sampler2D texture;\nuniform sampler2D layertexture;\nuniform sampler2D normaltexture;\nuniform sampler2D noise;\nfloat noise3d( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = texture2D(noise,(uv+0.5)/256.0,0.0).yx;\n    return -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\nfloat noise3dfbm3( in vec3 p )\n{\n  vec3 q = p;\n  float f;\n    f  = 0.50000*noise3d( q ); q = q*2.02;\n    f += 0.25000*noise3d( q ); q = q*2.03;\n    f += 0.12500*noise3d( q );\n  return clamp( 1.75*f, 0.0, 1.0 );\n}\nvec4 ColorRamp2Exp(float factor, float power, float pos0, float pos1, vec4 color0, vec4 color1){\n    vec4 outColor = color0;\n    if(factor >= pos0 && factor < pos1)\n    {\n        float localFactor = (factor - pos0)/(pos1 - pos0);\n        outColor =  mix(color0, color1, pow(localFactor, power));\n    }\n    else if (factor > pos1)\n    {\n        outColor = color1;\n    }\n    return outColor;\n}\nvoid main () {\n  vec4 data = texture2D(texture, v_uv0);\n  vec4 normalPS = texture2D(normaltexture, v_uv0);\n  float scale = 40.0;\n  float x0 = noise3d((v_worldpos.xyz + vec3(1,0,0))*  scale);\n  float x1 = noise3d((v_worldpos.xyz + vec3(-1,0,0))* scale);\n  float y0 = noise3d((v_worldpos.xyz + vec3(0,0,1))*  scale);\n  float y1 = noise3d((v_worldpos.xyz + vec3(0,0,-1))* scale);\n  float s = 10.0;\n  vec3 n = normalize(vec3(x1 - x0, s, y1 - y0));\n  normalPS.xyz = normalPS.xyz * 2.0 - 1.0;\n  normalPS.xyz = normalize(normalPS.xyz + n);\n  float noisedata = noise3dfbm3(v_worldpos.xyz*0.1);\n  vec3 albedo = texture2D(layertexture, v_data.xy + vec2((noisedata - 0.5) * 0.5 * max(0.0, v_data.x - 0.5))).rgb;\n  vec3 normal = -(normalPS.xyz);\n  vec3 lightcolor = normalize(vec3(1.0,-0.25,0.0));\n  float ndotl = max(0.0, dot(normal, lightcolor));\n  vec3 light = mix( vec3(0.02,0.03,0.1), vec3(0.3,0.4,0.9), data.g * data.g) + vec3(1.0,0.95,0.7) * 2.0 * ndotl * min(data.b, data.a);\n  vec4 final = vec4(1,1,1,1);\n  final.rgb = light * albedo * albedo;\n  float linearZ = v_worldpos.y * 0.004;\n  float linearDepth = length(v_worldpos.xyz - cc_cameraPos.xyz) / 1200.0;\n  vec4 heightFog = ColorRamp2Exp(linearZ, 0.2, 0.0, 0.6, vec4(1,1,1,1), vec4(0));\n  vec4 distFog = ColorRamp2Exp(linearDepth, 2.0, 0.0, 0.5, vec4(0), vec4(1));\n  distFog *= min(vec4(1), heightFog * 5.0);\n  final.rgb = mix(final.rgb, fogcolor.rgb * fogcolor.rgb, distFog.rgb * fogcolor.a);\n  final.rgb *= 0.5;\n  final.rgb = sqrt(final.rgb);\n  final.a = -v_vspos.z / 500.0;\n  gl_FragColor = final;\n}"
      }
    }
  ],
  "subMetas": {}
}