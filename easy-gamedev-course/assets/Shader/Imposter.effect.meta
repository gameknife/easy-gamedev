{
  "ver": "1.0.25",
  "uuid": "6cbb68b4-f0b8-4209-85d1-5a9d888f4f88",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matView;\nuniform mat4 cc_matViewInv;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nvarying vec4 v_color;\nattribute vec4 a_uv0;\nvarying vec2 v_uv0;\nvarying vec2 v_uv1;\nvarying vec4 v_worldpos;\nvarying vec4 v_vspos;\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  v_worldpos = pos;\n  float scale = a_uv0.z * 0.25 + 0.75;\n  pos.xyz += normalize(cc_matViewInv[0].xyz) * (a_uv0.x - 0.5) * scale * 2.0;\n  pos.xyz += normalize(cc_matViewInv[1].xyz) * (a_uv0.y - 0.5) * scale * 2.0;\n  pos.xyz += a_uv0.y * vec3(0.0,scale * 2.0,0.0);\n  pos =  cc_matViewProj * pos;\n  v_uv0 = a_uv0.xy;\n  v_uv1 = a_position.xz / 200.0 + vec2(0.5,0.5);\n  vec3 lightdir = normalize(vec3(1.0,-0.25,0.0));\n  v_color = cc_matView * vec4(lightdir,0.0);\n  v_vspos = cc_matView * v_worldpos;\n  gl_Position = pos;\n}",
        "frag": "\n  precision highp float;\nuniform vec4 cc_cameraPos;\n  varying vec4 v_color;\n  varying vec2 v_uv0;\n  varying vec2 v_uv1;\n  varying vec4 v_worldpos;\n  varying vec4 v_vspos;\n  uniform sampler2D texture;\n  uniform vec4 basecolor;\nuniform vec4 fogcolor;\n  vec3 rO = vec3(0.0);\n  vec3 sO = vec3(0.0, 0.0, -5.0);\n  float sR = 2.0;\n  float sR2 = 2.0*2.0;\n  float sR3 = 1.9*1.9;\nvec4 ColorRamp2Exp(float factor, float power, float pos0, float pos1, vec4 color0, vec4 color1){\n    vec4 outColor = color0;\n    if(factor >= pos0 && factor < pos1)\n    {\n        float localFactor = (factor - pos0)/(pos1 - pos0);\n        outColor =  mix(color0, color1, pow(localFactor, power));\n    }\n    else if (factor > pos1)\n    {\n        outColor = color1;\n    }\n    return outColor;\n}\n  void main () {\n    vec4 final = vec4(1, 1, 1, 1);\n    vec2 uv = v_uv0 - vec2(0.5);\n    vec3 rD = normalize(vec3(uv.x, uv.y, -1.0));\n    vec3 col = vec3(0.2);\n    vec3 A = sO - rO;\n    float B = dot(A, rD);\n    float C2 = dot(A, A) - B*B;\n    if (C2 > sR2) {\n      discard;\n    }\n    float tH = sqrt(sR2-C2);\n    float t = B - tH;\n    vec3 hitP = rO + rD * t;\n    vec3 normal = -normalize(hitP - sO);\n    col = -normal;\n    float ndotl = dot(normal,v_color.rgb);\n    ndotl = sqrt(max(0.0, ndotl) * 0.9 + 0.1);\n    vec4 data = texture2D(texture, v_uv1);\n    data.g = mix(data.g, min(1.0, data.g + 0.5), uv.y);\n    data.a = mix(data.a, 1.0, uv.y * 0.75 + 0.25);\n    float fresnel = max(0.0,1.0+normal.z);\n    float outline = max(0.0, pow(fresnel,2.0) ) * 1.0;\n    ndotl = min(1.0, ndotl + outline);\n    vec3 light = mix( vec3(0.02,0.03,0.1), vec3(0.3,0.4,0.9), data.g * data.g) + vec3(1.0,0.95,0.7) * 2.0 * ndotl * min(data.b,data.a);\n    final.rgb = light * basecolor.rgb * basecolor.rgb;\n    float linearZ = v_worldpos.y * 0.004;\n    float linearDepth = length(cc_cameraPos.xyz - v_worldpos.xyz) / 1200.0;\n    vec4 heightFog = ColorRamp2Exp(linearZ, 0.2, 0.0, 0.6, vec4(1,1,1,1), vec4(0));\n    vec4 distFog = ColorRamp2Exp(linearDepth, 2.0, 0.0, 0.5, vec4(0), vec4(1));\n    distFog *= min(vec4(1), heightFog * 5.0);\n    final.rgb = mix(final.rgb, fogcolor.rgb * fogcolor.rgb, distFog.rgb * fogcolor.a);\n    final *= 0.5;\n    final = sqrt(final);\n    final.a = -v_vspos.z / 500.0;\n    gl_FragColor = final;\n  }"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nout vec4 v_color;\nin vec4 a_uv0;\nout vec2 v_uv0;\nout vec2 v_uv1;\nout vec4 v_worldpos;\nout vec4 v_vspos;\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  v_worldpos = pos;\n  float scale = a_uv0.z * 0.25 + 0.75;\n  pos.xyz += normalize(cc_matViewInv[0].xyz) * (a_uv0.x - 0.5) * scale * 2.0;\n  pos.xyz += normalize(cc_matViewInv[1].xyz) * (a_uv0.y - 0.5) * scale * 2.0;\n  pos.xyz += a_uv0.y * vec3(0.0,scale * 2.0,0.0);\n  pos =  cc_matViewProj * pos;\n  v_uv0 = a_uv0.xy;\n  v_uv1 = a_position.xz / 200.0 + vec2(0.5,0.5);\n  vec3 lightdir = normalize(vec3(1.0,-0.25,0.0));\n  v_color = cc_matView * vec4(lightdir,0.0);\n  v_vspos = cc_matView * v_worldpos;\n  gl_Position = pos;\n}",
        "frag": "\n  precision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\n  in vec4 v_color;\n  in vec2 v_uv0;\n  in vec2 v_uv1;\n  in vec4 v_worldpos;\n  in vec4 v_vspos;\n  uniform sampler2D texture;\n  uniform UNLITPS {\n    vec4 basecolor;\n    vec4 fogcolor;\n  };\n  vec3 rO = vec3(0.0);\n  vec3 sO = vec3(0.0, 0.0, -5.0);\n  float sR = 2.0;\n  float sR2 = 2.0*2.0;\n  float sR3 = 1.9*1.9;\nvec4 ColorRamp2Exp(float factor, float power, float pos0, float pos1, vec4 color0, vec4 color1){\n    vec4 outColor = color0;\n    if(factor >= pos0 && factor < pos1)\n    {\n        float localFactor = (factor - pos0)/(pos1 - pos0);\n        outColor =  mix(color0, color1, pow(localFactor, power));\n    }\n    else if (factor > pos1)\n    {\n        outColor = color1;\n    }\n    return outColor;\n}\n  void main () {\n    vec4 final = vec4(1, 1, 1, 1);\n    vec2 uv = v_uv0 - vec2(0.5);\n    vec3 rD = normalize(vec3(uv.x, uv.y, -1.0));\n    vec3 col = vec3(0.2);\n    vec3 A = sO - rO;\n    float B = dot(A, rD);\n    float C2 = dot(A, A) - B*B;\n    if (C2 > sR2) {\n      discard;\n    }\n    float tH = sqrt(sR2-C2);\n    float t = B - tH;\n    vec3 hitP = rO + rD * t;\n    vec3 normal = -normalize(hitP - sO);\n    col = -normal;\n    float ndotl = dot(normal,v_color.rgb);\n    ndotl = sqrt(max(0.0, ndotl) * 0.9 + 0.1);\n    vec4 data = texture2D(texture, v_uv1);\n    data.g = mix(data.g, min(1.0, data.g + 0.5), uv.y);\n    data.a = mix(data.a, 1.0, uv.y * 0.75 + 0.25);\n    float fresnel = max(0.0,1.0+normal.z);\n    float outline = max(0.0, pow(fresnel,2.0) ) * 1.0;\n    ndotl = min(1.0, ndotl + outline);\n    vec3 light = mix( vec3(0.02,0.03,0.1), vec3(0.3,0.4,0.9), data.g * data.g) + vec3(1.0,0.95,0.7) * 2.0 * ndotl * min(data.b,data.a);\n    final.rgb = light * basecolor.rgb * basecolor.rgb;\n    float linearZ = v_worldpos.y * 0.004;\n    float linearDepth = length(cc_cameraPos.xyz - v_worldpos.xyz) / 1200.0;\n    vec4 heightFog = ColorRamp2Exp(linearZ, 0.2, 0.0, 0.6, vec4(1,1,1,1), vec4(0));\n    vec4 distFog = ColorRamp2Exp(linearDepth, 2.0, 0.0, 0.5, vec4(0), vec4(1));\n    distFog *= min(vec4(1), heightFog * 5.0);\n    final.rgb = mix(final.rgb, fogcolor.rgb * fogcolor.rgb, distFog.rgb * fogcolor.a);\n    final *= 0.5;\n    final = sqrt(final);\n    final.a = -v_vspos.z / 500.0;\n    gl_FragColor = final;\n  }"
      }
    }
  ],
  "subMetas": {}
}